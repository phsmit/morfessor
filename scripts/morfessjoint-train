#!/usr/bin/env python

import argparse
import logging
import random
import sys

import morfessor
import morfessjoint
from morfessjoint import _logger, get_version


def run(args):
    if args.verbose >= 2:
        loglevel = logging.DEBUG
    elif args.verbose >= 1:
        loglevel = logging.INFO
    else:
        loglevel = logging.WARNING

    logging_format = '%(asctime)s - %(message)s'
    date_format = '%Y-%m-%d %H:%M:%S'
    default_formatter = logging.Formatter(logging_format, date_format)
    plain_formatter = logging.Formatter('%(message)s')
    logging.basicConfig(level=loglevel)
    _logger.propagate = False  # do not forward messages to the root logger

    # Basic settings for logging to the error stream
    ch = logging.StreamHandler()
    ch.setLevel(loglevel)
    ch.setFormatter(plain_formatter)
    _logger.addHandler(ch)

    # Settings for when log_file is present
    if args.log_file is not None:
        fh = logging.FileHandler(args.log_file, 'w')
        fh.setLevel(loglevel)
        fh.setFormatter(default_formatter)
        _logger.addHandler(fh)
        # If logging to a file, make INFO the highest level for the
        # error stream
        ch.setLevel(max(loglevel, logging.INFO))

    # If debug messages are printed to screen or if stderr is not a tty (but
    # a pipe or a file), don't show the progressbar
    global show_progress_bar
    if (ch.level > logging.INFO or
            (hasattr(sys.stderr, 'isatty') and not sys.stderr.isatty())):
        show_progress_bar = False

    if args.progress:
        show_progress_bar = True
        ch.setLevel(min(ch.level, logging.INFO))


    if args.randseed is not None:
        random.seed(args.randseed)

    io = morfessor.MorfessorIO(encoding='utf-8',
                 lowercase=args.lowercase)


    model = morfessjoint.BaselineModel(corpusweight=args.corpusweight)

    data = []
    for f in args.trainfiles:
        for line in io._read_text_file(f):
            word, trans = line.split("\t", 1)
            trans = tuple(trans.split())
            data.append((1, (word, trans)))

    if args.dampening == 'none':
        dampfunc = None
    elif args.dampening == 'log':
        dampfunc = lambda x: int(round(math.log(x + 1, 2)))
    elif args.dampening == 'ones':
        dampfunc = lambda x: 1
    else:
        raise ArgumentException("unknown dampening type '%s'" % args.dampening)

    c = model.load_data(data, count_modifier=dampfunc)
    e, c = model.train_batch(finish_threshold=args.finish_threshold)
    _logger.info("Epochs: %s" % e)

    segmentations = list(model.get_segmentations())

    if args.lexfile is not None:
        lex = {}
        for _, _, w in segmentations:
            for p in w:
                if p[0] not in lex:
                    lex[p[0]] = set()
                lex[p[0]].add(p[1])

        with io._open_text_file_write(args.lexfile) as fd:
            for k, vals in sorted(lex.items()):
                for v in sorted(vals):
                    fd.write(u"{}\t{}\n".format(k," ".join(v)))

    realmodel = morfessor.BaselineModel()
    cleaned_segs = []
    cleaned_segs2 = []
    for c, word, w in segmentations:
        cleaned_segs.append((c, tuple(p[0] for p in w)))
        cleaned_segs2.append((c, word[0], tuple(p[0] for p in w)))

    realmodel.load_segmentations(cleaned_segs)
    # Save model
    if args.savefile is not None:
        io.write_binary_model_file(args.savefile, realmodel)

    if args.savesegfile is not None:
        io.write_segmentation_file(args.savesegfile, cleaned_segs)







def main(argv):
    parser = argparse.ArgumentParser(
        prog='morfessjoint-train',
        description="""
    Morfessor %s

    Copyright (c) 2012-2014, Sami Virpioja and Peter Smit
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1.  Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

    2.  Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.

    Command-line arguments:
    """ % get_version(),
        epilog="""
    Simple usage examples (training):

      %(prog)s -t training_corpus.txt -s model.pickled -S model.txt -x out-dict
    """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        add_help=False)

    add_arg = parser.add_argument_group('input data files').add_argument
    add_arg('-t', '--traindata', dest='trainfiles', action='append',
            default=[], metavar='<file>',
            help="input corpus file(s) for training (text or bz2/gzipped text;"
                 " use '-' for standard input; add several times in order to "
                 "append multiple files)")

    add_arg = parser.add_argument_group('output data files').add_argument
    add_arg('-s', '--save', dest="savefile", default=None, metavar='<file>',
            help="save final (grapheme only) model to file (pickled model object)")
    add_arg('-S', '--save-segmentation', dest="savesegfile", default=None,
            metavar='<file>',
            help="save (grapheme only) model segmentations to file (Morfessor 1.0 format)")

    add_arg('-x', '--lexicon', dest="lexfile", default=None, metavar='<file>',
            help="output joint lexicon to given file")

    add_arg = parser.add_argument_group(
        'data format options').add_argument
    add_arg('--lowercase', dest="lowercase", default=False,
            action='store_true',
            help="lowercase input data")

    add_arg = parser.add_argument_group(
        'training and segmentation options').add_argument
    add_arg('-F', '--finish-threshold', dest='finish_threshold', type=float,
            default=0.005, metavar='<float>',
            help="Stopping threshold. Training stops when "
                 "the improvement of the last iteration is"
                 "smaller then finish_threshold * #boundaries; "
                 "(default '%(default)s')")
    add_arg('-r', '--randseed', dest="randseed", default=None,
            metavar='<seed>',
            help="seed for random number generator")
    add_arg('-d', '--dampening', dest="dampening", type=_str, default='ones',
            metavar='<type>', choices=['none', 'log', 'ones'],
            help="frequency dampening for training data ('none', 'log', or "
                 "'ones'; default '%(default)s')")


    # Options for semi-supervised model training
    add_arg = parser.add_argument_group(
        'semi-supervised training options').add_argument
    add_arg('-w', '--corpusweight', dest="corpusweight", type=float,
            default=1.0, metavar='<float>',
            help="corpus weight parameter (default %(default)s); "
                 "sets the initial value if other tuning options are used")

    # Options for evaluation
    add_arg = parser.add_argument_group('Evaluation options').add_argument
    add_arg('-G', '--goldstandard', dest='goldstandard', default=None,
            metavar='<file>',
            help='If provided, evaluate the model against the gold standard')

    # Options for logging
    add_arg = parser.add_argument_group('logging options').add_argument
    add_arg('-v', '--verbose', dest="verbose", type=int, default=1,
            metavar='<int>',
            help="verbose level; controls what is written to the standard "
                 "error stream or log file (default %(default)s)")
    add_arg('--logfile', dest='log_file', metavar='<file>',
            help="write log messages to file in addition to standard "
                 "error stream")
    add_arg('--progressbar', dest='progress', default=False,
            action='store_true',
            help="Force the progressbar to be displayed (possibly lowers the "
                 "log level for the standard error stream)")

    add_arg = parser.add_argument_group('other options').add_argument
    add_arg('-h', '--help', action='help',
            help="show this help message and exit")
    add_arg('--version', action='version',
            version='%(prog)s ' + get_version(),
            help="show version number and exit")

    try:
        args = parser.parse_args(argv)
        run(args)
    except morfessor.ArgumentException as e:
        parser.error(e)
    except Exception as e:
        _logger.error("Fatal Error {} {}".format(type(e), e))
        raise


if __name__ == "__main__":
    main(sys.argv[1:])
